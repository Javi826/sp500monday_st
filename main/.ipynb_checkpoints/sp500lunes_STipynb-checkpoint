{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c56f94e9-a5de-4870-be9a-73c7efe9e06d",
   "metadata": {
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Ruta actual: C:\\Users\\jlaho\\Desktop\\ML\\ageron\\sp500monday_ST\\main\n",
      "[*********************100%%**********************]  1 of 1 completed\n",
      "Step 01 OK: reading file\n",
      "START MODUL mod_dtset_clean\n",
      "Step 01 OK: day_week\n",
      "Step 02 OK: sort_columns\n",
      "Step 03 OK: rounding_data\n",
      "DataFrame saved in: C:\\Users\\jlaho\\Desktop\\Programas\\Spyder\\sp500monday_ST\\inputs\\historicyh\\df_data_cleanSPX.xlsx\n",
      "END MODUL mod_dtset_clean\n",
      "\n",
      "\n",
      "INICIO Iteración: 1 - 1\n",
      "Paso 01 OK\n",
      "Paso 02 OK\n",
      "Paso 03 OK\n",
      "Paso 04 OK\n",
      "Paso 05 OK\n",
      "Paso 06 OK\n",
      "Paso 07 OK\n",
      "Paso 08 OK\n",
      "Paso 09 OK\n",
      "Paso 10 OK\n",
      "Paso 11 OK\n",
      "Paso 12 OK\n",
      "\n",
      "FINAL Iteración: 1 - 1\n",
      "\n",
      "INICIO Iteración: 1 - 2\n",
      "Paso 01 OK\n",
      "Paso 02 OK\n",
      "Paso 03 OK\n",
      "Paso 04 OK\n",
      "Paso 05 OK\n",
      "Paso 06 OK\n",
      "Paso 07 OK\n",
      "Paso 08 OK\n",
      "Paso 09 OK\n",
      "Paso 10 OK\n",
      "Paso 11 OK\n",
      "Paso 12 OK\n",
      "\n",
      "FINAL Iteración: 1 - 2\n",
      "\n",
      "INICIO Iteración: 1 - 3\n",
      "Paso 01 OK\n",
      "Paso 02 OK\n",
      "Paso 03 OK\n",
      "Paso 04 OK\n",
      "Paso 05 OK\n",
      "Paso 06 OK\n",
      "Paso 07 OK\n",
      "Paso 08 OK\n",
      "Paso 09 OK\n",
      "Paso 10 OK\n",
      "Paso 11 OK\n",
      "Paso 12 OK\n",
      "\n",
      "FINAL Iteración: 1 - 3\n",
      "\n",
      "INICIO Iteración: 1 - 4\n",
      "Paso 01 OK\n",
      "Paso 02 OK\n",
      "Paso 03 OK\n",
      "Paso 04 OK\n",
      "Paso 05 OK\n",
      "Paso 06 OK\n",
      "Paso 07 OK\n",
      "Paso 08 OK\n",
      "Paso 09 OK\n",
      "Paso 10 OK\n",
      "Paso 11 OK\n",
      "Paso 12 OK\n",
      "\n",
      "FINAL Iteración: 1 - 4\n",
      "\n",
      "INICIO Iteración: 1 - 5\n",
      "Paso 01 OK\n",
      "Paso 02 OK\n",
      "Paso 03 OK\n",
      "Paso 04 OK\n",
      "Paso 05 OK\n",
      "Paso 06 OK\n",
      "Paso 07 OK\n",
      "Paso 08 OK\n",
      "Paso 09 OK\n",
      "Paso 10 OK\n",
      "Paso 11 OK\n",
      "Paso 12 OK\n",
      "\n",
      "FINAL Iteración: 1 - 5\n",
      "\n",
      "INICIO Iteración: 1 - 6\n",
      "Paso 01 OK\n",
      "Paso 02 OK\n",
      "Paso 03 OK\n",
      "Paso 04 OK\n",
      "Paso 05 OK\n",
      "Paso 06 OK\n",
      "Paso 07 OK\n",
      "Paso 08 OK\n",
      "Paso 09 OK\n",
      "Paso 10 OK\n",
      "Paso 11 OK\n",
      "Paso 12 OK\n",
      "\n",
      "FINAL Iteración: 1 - 6\n",
      "\n",
      "INICIO Iteración: 1 - 7\n",
      "Paso 01 OK\n",
      "Paso 02 OK\n",
      "Paso 03 OK\n",
      "Paso 04 OK\n",
      "Paso 05 OK\n",
      "Paso 06 OK\n",
      "Paso 07 OK\n",
      "Paso 08 OK\n",
      "Paso 09 OK\n",
      "Paso 10 OK\n",
      "Paso 11 OK\n",
      "Paso 12 OK\n",
      "\n",
      "FINAL Iteración: 1 - 7\n",
      "\n",
      "INICIO Iteración: 1 - 8\n",
      "Paso 01 OK\n",
      "Paso 02 OK\n",
      "Paso 03 OK\n",
      "Paso 04 OK\n",
      "Paso 05 OK\n",
      "Paso 06 OK\n",
      "Paso 07 OK\n",
      "Paso 08 OK\n",
      "Paso 09 OK\n",
      "Paso 10 OK\n",
      "Paso 11 OK\n",
      "Paso 12 OK\n",
      "\n",
      "FINAL Iteración: 1 - 8\n",
      "\n",
      "INICIO Iteración: 1 - 9\n",
      "Paso 01 OK\n",
      "Paso 02 OK\n",
      "Paso 03 OK\n",
      "Paso 04 OK\n",
      "Paso 05 OK\n",
      "Paso 06 OK\n",
      "Paso 07 OK\n",
      "Paso 08 OK\n",
      "Paso 09 OK\n",
      "Paso 10 OK\n",
      "Paso 11 OK\n",
      "Paso 12 OK\n",
      "\n",
      "FINAL Iteración: 1 - 9\n",
      "\n",
      "INICIO Iteración: 1 - 10\n",
      "Paso 01 OK\n",
      "Paso 02 OK\n",
      "Paso 03 OK\n",
      "Paso 04 OK\n",
      "Paso 05 OK\n",
      "Paso 06 OK\n",
      "Paso 07 OK\n",
      "Paso 08 OK\n",
      "Paso 09 OK\n",
      "Paso 10 OK\n",
      "Paso 11 OK\n",
      "Paso 12 OK\n",
      "\n",
      "FINAL Iteración: 1 - 10\n",
      "\n",
      "INICIO Iteración: 2 - 1\n",
      "Paso 01 OK\n",
      "Paso 02 OK\n",
      "Paso 03 OK\n",
      "Paso 04 OK\n",
      "Paso 05 OK\n",
      "Paso 06 OK\n",
      "Paso 07 OK\n",
      "Paso 08 OK\n",
      "Paso 09 OK\n",
      "Paso 10 OK\n",
      "Paso 11 OK\n",
      "Paso 12 OK\n",
      "\n",
      "FINAL Iteración: 2 - 1\n",
      "\n",
      "INICIO Iteración: 2 - 2\n",
      "Paso 01 OK\n",
      "Paso 02 OK\n",
      "Paso 03 OK\n",
      "Paso 04 OK\n",
      "Paso 05 OK\n",
      "Paso 06 OK\n",
      "Paso 07 OK\n",
      "Paso 08 OK\n",
      "Paso 09 OK\n",
      "Paso 10 OK\n",
      "Paso 11 OK\n",
      "Paso 12 OK\n",
      "\n",
      "FINAL Iteración: 2 - 2\n",
      "\n",
      "INICIO Iteración: 2 - 3\n",
      "Paso 01 OK\n",
      "Paso 02 OK\n",
      "Paso 03 OK\n",
      "Paso 04 OK\n",
      "Paso 05 OK\n",
      "Paso 06 OK\n",
      "Paso 07 OK\n",
      "Paso 08 OK\n",
      "Paso 09 OK\n",
      "Paso 10 OK\n",
      "Paso 11 OK\n",
      "Paso 12 OK\n",
      "\n",
      "FINAL Iteración: 2 - 3\n",
      "\n",
      "INICIO Iteración: 2 - 4\n"
     ]
    }
   ],
   "source": [
    "# -*- coding: utf-8 -*-\n",
    "#Created on Sat Dec 23 14:21:22 2023\n",
    "import os\n",
    "import pandas as pd\n",
    "import numpy as np\n",
    "import warnings\n",
    "import time\n",
    "import yfinance as yf\n",
    "import sys\n",
    "from modules.mod_dtset_clean import mod_dtset_clean\n",
    "\n",
    "#TIMING\n",
    "inicio_tiempo = time.time()\n",
    "\n",
    "#IGNORE WARNINGS\n",
    "warnings.filterwarnings(\"ignore\")\n",
    "\n",
    "#VISUALIZATION PRINTS\n",
    "pd.set_option('display.max_columns', None)\n",
    "pd.set_option('display.expand_frame_repr', False)\n",
    "\n",
    "# PATHS \n",
    "path_base = r\"C:\\Users\\jlaho\\Desktop\\Programas\\Spyder\\sp500monday_ST\"\n",
    "folder = \"inputs\\historicyh\"\n",
    "archivo = \"sp500_datayh.csv\"\n",
    "path_absolut = os.path.join(path_base, folder, archivo)\n",
    "current_directory = os.getcwd()\n",
    "print(\"Ruta actual:\", current_directory) \n",
    "\n",
    "# INDEX SYMBOL\n",
    "#symbol = \"^GSPC\"\n",
    "symbol = \"^NDX\"\n",
    "\n",
    "# DATA DATE PERIOD\n",
    "start_date = \"2000-01-03\"\n",
    "end_date = \"2023-12-01\"\n",
    "\n",
    "# YAHOO CALL\n",
    "sp500_data = yf.download(symbol, start=start_date, end=end_date)\n",
    "\n",
    "# DIRECTORY YAHOO CSV file\n",
    "csv_folder = r\"C:\\Users\\jlaho\\Desktop\\Programas\\Spyder\\sp500monday_ST\\inputs\\historicyh\"\n",
    "\n",
    "# Ensure the folder exists or create it if it doesn't\n",
    "if not os.path.exists(csv_folder): os.makedirs(csv_folder)\n",
    "\n",
    "# YAHOO FILE SAVING\n",
    "csv_file_path = os.path.join(csv_folder, \"sp500_datayh.csv\")\n",
    "sp500_data.to_csv(csv_file_path)\n",
    "\n",
    "# YAHOO FILE READING\n",
    "df_data = pd.read_csv(csv_file_path, header=None, skiprows=1, names=['date','open','high','low','close','adj_close','volume'])\n",
    "print(\"Step 01 OK: reading file\")\n",
    "\n",
    "#DATA SET CLEANING\n",
    "df_clean=mod_dtset_clean(df_data)\n",
    "\n",
    "#sys.exit()\n",
    "\n",
    "      \n",
    "# DATA YAHOO CLEANING DOWNLOADED FOLDER\n",
    "folder = \"inputs\\historicyh\"\n",
    "archivo = \"df_data_cleanSPX.xlsx\"\n",
    "#\n",
    "ruta_salir_main = os.path.dirname(current_directory)\n",
    "ruta_absoluta = os.path.join(ruta_salir_main, folder, archivo)\n",
    "\n",
    "\n",
    "# Especifica la carpeta principal\n",
    "carpeta_principal = 'outputs'\n",
    "\n",
    "\n",
    "# Verifica si la carpeta principal existe, y si no, la crea\n",
    "if not os.path.exists(os.path.join(ruta_salir_main, carpeta_principal)):\n",
    "    os.makedirs(os.path.join(ruta_salir_main, carpeta_principal))\n",
    "\n",
    "# Carpetas dentro de la carpeta principal\n",
    "carpeta_salidas = os.path.join(ruta_salir_main, carpeta_principal, 'salidas')\n",
    "if not os.path.exists(carpeta_salidas):\n",
    "    os.makedirs(carpeta_salidas)\n",
    "\n",
    "# Carpetas dentro de la carpeta principal\n",
    "carpeta_operaciones = os.path.join(ruta_salir_main, carpeta_principal, 'operaciones')\n",
    "if not os.path.exists(carpeta_operaciones):\n",
    "    os.makedirs(carpeta_operaciones)\n",
    "\n",
    "# Carpetas dentro de la carpeta principal\n",
    "carpeta_rentabilidades = os.path.join(ruta_salir_main, carpeta_principal, 'rentabilidades')\n",
    "if not os.path.exists(carpeta_rentabilidades):\n",
    "    os.makedirs(carpeta_rentabilidades)\n",
    "\n",
    "# Carpetas dentro de la carpeta principal\n",
    "carpeta_briefs = os.path.join(ruta_salir_main, carpeta_principal, 'briefs')\n",
    "if not os.path.exists(carpeta_briefs):\n",
    "    os.makedirs(carpeta_briefs)\n",
    "\n",
    "# Verificar si se deben reiniciar los DataFrames al principio\n",
    "reiniciar_dataframes = True  # Puedes ajustar esto según tus necesidades\n",
    "\n",
    "# Reiniciar o definir el DataFrame principal\n",
    "if 'dataframe' in locals() and reiniciar_dataframes:\n",
    "    del dataframe  # Eliminar el DataFrame existente si existe\n",
    "dataframe = pd.DataFrame()\n",
    "\n",
    "# Definir variables\n",
    "num_dias_retroceder_values = [1,2,3,4,5]\n",
    "max_dias_ejecucion_venta_values = [1,2,3,4,5,6,7,8,9,10]\n",
    "#num_dias_retroceder_values = [1,2]\n",
    "#max_dias_ejecucion_venta_values = [1,2]\n",
    "comision = 0\n",
    "annus = 23\n",
    "evalua_lunes = 5\n",
    "\n",
    "df_brief_columns = ['bf_annus', 'bf_num_dias_retroceder', 'bf_max_dias_ejecucion_venta',\n",
    "                    'bf_agrupa_operacion', 'bf_dias_ejecuta_venta', 'bf_%operacion','bf_%renta']\n",
    "\n",
    "\n",
    "df_brief_data = []\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "for num_dias_retroceder in num_dias_retroceder_values:\n",
    "    for max_dias_ejecucion_venta in max_dias_ejecucion_venta_values:\n",
    "        print(f\"\\nINICIO Iteración: {num_dias_retroceder} - {max_dias_ejecucion_venta}\")\n",
    "        \n",
    "        # Lee el archivo excel en un DataFrame de pandas\n",
    "        dataframe = pd.read_excel(ruta_absoluta)\n",
    "\n",
    "        \n",
    "        # Añade una nueva columna llamada 'iden' con numeración de cada registro\n",
    "        dataframe['iden'] = range(1, len(dataframe) + 1)\n",
    "\n",
    "        # Formatea la columna 'iden' para que tenga 5 dígitos\n",
    "        dataframe['iden'] = dataframe['iden'].apply(lambda x: f'{x:05d}')\n",
    "\n",
    "\n",
    "        # Especifica la condición para seleccionar las filas\n",
    "        condicion_dia_lunes=dataframe['dia_semana_dia'] == 'Monday'\n",
    "\n",
    "        # Agrega una nueva columna al DataFrame original para indicar si la condición se cumple\n",
    "        dataframe['condicion_dia_lunes'] = condicion_dia_lunes\n",
    "\n",
    "        # Agrega una nueva columna adicional que compara el valor de la columna 'ultimo_precio'\n",
    "        # con los registros de 'ultimo_precio' en las filas posteriores hasta 'num_dias_retroceder'\n",
    "        condicion_compra_dias_bajando = None  # Inicializamos con None para la primera iteración\n",
    "\n",
    "        for i in range(1, num_dias_retroceder + 1):\n",
    "            condicion_actual = dataframe['ultimo_precio'] <= dataframe['ultimo_precio'].shift(i)\n",
    "            if  condicion_compra_dias_bajando is None:\n",
    "                condicion_compra_dias_bajando = condicion_actual\n",
    "            else:\n",
    "                condicion_compra_dias_bajando &= condicion_actual\n",
    "\n",
    "        dataframe['condicion_compra_dias_bajando'] = condicion_compra_dias_bajando\n",
    "\n",
    "        # Asigna True a las filas donde ambas condiciones son verdaderas\n",
    "        dataframe['iden_lunes_compra'] = condicion_compra_dias_bajando & condicion_dia_lunes\n",
    "\n",
    "        dataframe['iden_lunes_compra'] = np.where(dataframe['iden_lunes_compra'],'Pot Lunes Compra','')\n",
    "\n",
    "        # Agrega una nueva columna llamada 'cont_pot' con valor 1 si 'iden_lunes_compra' es igual a 'Pot Lunes Compra' y 0 de lo contrario\n",
    "        dataframe['cont_pot'] = np.where(dataframe['iden_lunes_compra'] == 'Pot Lunes Compra', 1, 0)\n",
    "\n",
    "        # Agrega una nueva columna llamada 'sum_cont_pot'\n",
    "        dataframe['sum_cont_pot'] = 0\n",
    "\n",
    "        # Itera sobre el DataFrame\n",
    "        for i in range(len(dataframe)):\n",
    "            if dataframe.at[i, 'cont_pot'] == 1:\n",
    "                # Suma los valores de 'cont_pot' de los registros anteriores hasta un máximo de 'max_dias_ejecucion_venta'\n",
    "                sum_cont_pot = dataframe.loc[max(0, i - max_dias_ejecucion_venta):i - 1, 'cont_pot'].sum()\n",
    "                dataframe.at[i, 'sum_cont_pot'] = sum_cont_pot\n",
    "\n",
    "        # Agrega una columna adicional 'contador_venta' con la lógica especificada\n",
    "        dataframe['cont_venta'] = np.where(\n",
    "            (dataframe['ultimo_precio'] > dataframe['maximo_dia'].shift(1)),\n",
    "           1,\n",
    "           0\n",
    "        )\n",
    "\n",
    "        # Agrega una nueva columna llamada 'sum_cont_venta'\n",
    "        dataframe['sum_cont_venta'] = 0\n",
    "\n",
    "        # Itera sobre el DataFrame\n",
    "        for i in range(len(dataframe)):\n",
    "            if dataframe.at[i, 'cont_pot'] == 1:\n",
    "                # Suma los valores de 'cont_venta' de los registros anteriores\n",
    "                # hasta un máximo de 'evalua_lunes' en lugar de 'max_dias_ejecucion_venta'\n",
    "                sum_cont_venta = dataframe.loc[max(0, i - evalua_lunes):i, 'cont_venta'].sum()\n",
    "                dataframe.at[i, 'sum_cont_venta'] = sum_cont_venta\n",
    "                \n",
    "        print(\"Paso 01 OK\")    \n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "        # Agrega una nueva columna llamada 'ejecuta_lunes' con las condiciones dadas y secuencia numérica\n",
    "        dataframe['ejecuta_lunes'] = '' \n",
    "        contador_secuencia = 1\n",
    "\n",
    "        for i in range(len(dataframe)):\n",
    "            if (dataframe.at[i, 'cont_pot'] == 1) and (dataframe.at[i, 'sum_cont_pot'] == 0):\n",
    "                dataframe.at[i, 'ejecuta_lunes'] = f'Si Compra Lunes_1_{str(contador_secuencia).zfill(3)}'\n",
    "                contador_secuencia += 1\n",
    "            elif (dataframe.at[i, 'cont_pot'] == 1) and (dataframe.at[i, 'sum_cont_pot'] != 0) and (dataframe.at[i, 'sum_cont_venta'] != 0):\n",
    "                dataframe.at[i, 'ejecuta_lunes'] = f'Si Compra Lunes_2_{str(contador_secuencia).zfill(3)}'\n",
    "                contador_secuencia += 1\n",
    "            elif (dataframe.at[i, 'cont_pot'] == 1) and (dataframe.at[i, 'sum_cont_pot'] != 0) and (dataframe.at[i, 'sum_cont_venta'] == 0):\n",
    "                dataframe.at[i, 'ejecuta_lunes'] = 'No Compra Lunes'\n",
    "\n",
    "\n",
    "        # Agrega una nueva columna llamada 'cont_ejecuta_lunes'\n",
    "        dataframe['cont_ejecuta_lunes'] = np.where(dataframe['ejecuta_lunes'].str.startswith('Si Compra Lunes'), 1, 0)\n",
    "\n",
    "\n",
    "        print(\"Paso 02 OK\")\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------        \n",
    "                # Inicializa el número de secuencia\n",
    "        contador_secuencia = 1\n",
    "\n",
    "        # Agrega una nueva columna llamada 'ejecuta_venta'\n",
    "        dataframe['ejecuta_venta'] = ''\n",
    "\n",
    "        # Itera sobre todos los índices\n",
    "        for indice_ejecuta_lunes in dataframe[dataframe['cont_ejecuta_lunes'] == 1].index:\n",
    "            # Inicializa el número de secuencia aquí para cada compra\n",
    "            num_secuencia = int(dataframe['ejecuta_lunes'].iloc[indice_ejecuta_lunes].split('_')[-1])\n",
    "            encontrado = False\n",
    "            # Resto del código para la venta\n",
    "            for i in range(1, min(max_dias_ejecucion_venta + 1, len(dataframe) - indice_ejecuta_lunes)):\n",
    "                if dataframe['cont_venta'].iloc[indice_ejecuta_lunes + i] == 1:\n",
    "                    # Actualiza el DataFrame para ese día\n",
    "                    dataframe.at[indice_ejecuta_lunes + i, 'ejecuta_venta'] = f'venta_{str(num_secuencia).zfill(3)}_ejecutada_dia_{str(i).zfill(3)}'\n",
    "                    encontrado = True\n",
    "                    break\n",
    "\n",
    "            # Si no se encontró venta dentro del límite, asigna un valor específico al día máximo\n",
    "            if not encontrado:\n",
    "                max_dia_ejecucion_venta = min(max_dias_ejecucion_venta, len(dataframe) - indice_ejecuta_lunes - 1)\n",
    "                dataframe.at[indice_ejecuta_lunes + max_dia_ejecucion_venta, 'ejecuta_venta'] = f'venta_{str(num_secuencia).zfill(3)}_ejecutada_dia_{str(max_dias_ejecucion_venta).zfill(3)}'\n",
    "\n",
    "\n",
    "\n",
    "        # Agrega una nueva columna llamada 'cont_ejecuta_lunes'\n",
    "        dataframe['cont_ejecuta_venta'] = np.where(dataframe['ejecuta_venta'].str.startswith('venta_'), 1, 0)\n",
    "\n",
    "        print(\"Paso 03 OK\")\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------        \n",
    "        # Agrega una nueva columna llamada 'carga_operacion'\n",
    "        dataframe['carga_operacion'] = ''\n",
    "\n",
    "        # Itera sobre todos los índices donde 'cont_ejecuta_lunes' es igual a 1\n",
    "        for indice_ejecuta_lunes in dataframe[dataframe['cont_ejecuta_lunes'] == 1].index:\n",
    "            # Obtiene el número de secuencia de la compra\n",
    "            num_secuencia_compra = int(dataframe['ejecuta_lunes'].iloc[indice_ejecuta_lunes].split('_')[-1])\n",
    "\n",
    "            # Asigna el valor correspondiente en la columna 'carga_operacion' para la compra\n",
    "            dataframe.at[indice_ejecuta_lunes, 'carga_operacion'] = f'Operacion_C_{str(num_secuencia_compra).zfill(3)}'\n",
    "\n",
    "        # Itera sobre todos los índices donde 'cont_ejecuta_venta' es igual a 1\n",
    "        for indice_ejecuta_venta in dataframe[dataframe['cont_ejecuta_venta'] == 1].index:\n",
    "            # Obtiene el número de secuencia de la venta\n",
    "            num_secuencia_venta = int(dataframe['ejecuta_venta'].iloc[indice_ejecuta_venta].split('_')[1])\n",
    "\n",
    "            # Obtiene el número de días que tarda en ejecutarse la venta\n",
    "            dias_ejecucion_venta = int(dataframe['ejecuta_venta'].iloc[indice_ejecuta_venta].split('_')[-1])\n",
    "\n",
    "            # Asigna el valor correspondiente en la columna 'carga_operacion' para la venta\n",
    "            dataframe.at[indice_ejecuta_venta, 'carga_operacion'] = f'Operacion_V_{str(num_secuencia_venta).zfill(3)}_{str(dias_ejecucion_venta).zfill(3)}'\n",
    "\n",
    "        print(\"Paso 04 OK\")\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------        \n",
    "                # Cambia el nombre de la nueva columna de 'ejecuta_operacion' a 'agrupa_operacion'\n",
    "        dataframe['agrupa_operacion'] = ''\n",
    "\n",
    "        # Itera sobre el DataFrame\n",
    "        for i in range(len(dataframe) - 1):\n",
    "            # Verifica si el registro actual en 'carga_operacion' comienza con 'Operacion_C_'\n",
    "            if dataframe['carga_operacion'].iloc[i].startswith('Operacion_C_'):\n",
    "                # Encuentra el siguiente índice donde 'carga_operacion' está informado\n",
    "                siguiente_indice = i + 1\n",
    "                while siguiente_indice < len(dataframe) and not dataframe['carga_operacion'].iloc[siguiente_indice]:\n",
    "                    siguiente_indice += 1\n",
    "\n",
    "                # Verifica si encontró un siguiente registro informado\n",
    "                if siguiente_indice < len(dataframe):\n",
    "                    # Obtén los últimos tres dígitos del siguiente registro en 'carga_operacion' separados por '_'\n",
    "                    ultimos_tres_digitos = dataframe['carga_operacion'].iloc[siguiente_indice].split('_')[-1]\n",
    "\n",
    "                    # Combina el registro actual con los últimos tres dígitos del siguiente registro en 'carga_operacion'\n",
    "                    nuevo_valor = f\"{dataframe['carga_operacion'].iloc[i]}_{ultimos_tres_digitos}\"\n",
    "\n",
    "                    # Asigna el nuevo valor a la columna 'agrupa_operacion'\n",
    "                    dataframe.at[i, 'agrupa_operacion'] = nuevo_valor\n",
    "                else:\n",
    "                    # Si no hay un siguiente registro informado, el registro es el mismo\n",
    "                    dataframe.at[i, 'agrupa_operacion'] = dataframe['carga_operacion'].iloc[i]\n",
    "            elif dataframe['carga_operacion'].iloc[i].startswith('Operacion_V_'):\n",
    "                # Para los registros que comienzan con 'Operacion_V_', el registro es el mismo\n",
    "                dataframe.at[i, 'agrupa_operacion'] = dataframe['carga_operacion'].iloc[i]\n",
    "\n",
    "        # El último registro de 'agrupa_operacion' será el mismo que el último registro de 'carga_operacion'\n",
    "        dataframe.at[len(dataframe) - 1, 'agrupa_operacion'] = dataframe['carga_operacion'].iloc[len(dataframe) - 1]\n",
    "      \n",
    "        print(\"Paso 05 OK\")\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------        \n",
    "        # Especifica la ruta para guardar el nuevo archivo Excel con el nombre personalizado\n",
    "        nombre_archivo_salida = f'df_salida_{annus}_{num_dias_retroceder:03d}_{max_dias_ejecucion_venta:03d}.xlsx'\n",
    "        ruta_df_salida = os.path.join(carpeta_salidas, nombre_archivo_salida)\n",
    "\n",
    "        # Guarda el DataFrame resultante en un nuevo archivo Excel con la hoja llamada \"Master\"\n",
    "        dataframe.to_excel(ruta_df_salida, sheet_name='Master', index=False)\n",
    "\n",
    "        #print(f\"\\nEl DataFrame se ha guardado en '{ruta_df_salida}' con la hoja 'Master'.\")\n",
    "        print(\"Paso 06 OK\")\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------        \n",
    "        # Define el nombre para el segundo archivo Excel con el DataFrame limpio\n",
    "        nombre_archivo_salida_limpia = f'df_salida_limpia_{annus}_{num_dias_retroceder:03d}_{max_dias_ejecucion_venta:03d}.xlsx'\n",
    "        ruta_df_salida_limpia = os.path.join(carpeta_salidas, nombre_archivo_salida_limpia)\n",
    "\n",
    "        # Define las columnas seleccionadas y su orden\n",
    "        columnas_seleccionadas = ['iden', 'fecha_formato', 'dia_semana_dia', 'ultimo_precio', 'apertura_dia', 'maximo_dia', 'ejecuta_lunes', 'ejecuta_venta', 'carga_operacion', 'agrupa_operacion']\n",
    "\n",
    "        # Crea un nuevo DataFrame con las columnas seleccionadas\n",
    "        dataframe_limpio = dataframe[columnas_seleccionadas]\n",
    "\n",
    "        # Guarda el DataFrame limpio en un nuevo archivo Excel con el nombre personalizado\n",
    "        dataframe_limpio.to_excel(ruta_df_salida_limpia, sheet_name='Master', index=False)\n",
    "\n",
    "        \n",
    "        print(\"Paso 07 OK\")\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------        \n",
    "        # Especifica la ruta para leer el archivo Excel con el nombre personalizado\n",
    "        nombre_archivo_entrada = f'df_salida_{annus}_{num_dias_retroceder:03d}_{max_dias_ejecucion_venta:03d}.xlsx'\n",
    "        ruta_df_salida = os.path.join(carpeta_salidas, nombre_archivo_entrada)\n",
    "\n",
    "        # Lee el archivo DataFrameSalida.xlsx en un DataFrame de pandas\n",
    "        df_salida = pd.read_excel(ruta_df_salida, sheet_name='Master')\n",
    "\n",
    "        # Filtra solo los registros con información en la columna 'agrupa_operacion'\n",
    "        df_operaciones = df_salida[df_salida['agrupa_operacion'].notnull()]\n",
    "\n",
    "        # Especifica la ruta para leer el archivo Excel de operaciones con el nombre personalizado\n",
    "        nombre_archivo_operaciones = f'df_operaciones_{annus}_{num_dias_retroceder:03d}_{max_dias_ejecucion_venta:03d}.xlsx'\n",
    "        ruta_df_operaciones = os.path.join(carpeta_operaciones, nombre_archivo_operaciones)\n",
    "\n",
    "        # Guarda los registros filtrados en un nuevo archivo Excel con la hoja llamada \"Operaciones\"\n",
    "        df_operaciones[['iden', 'fecha_formato', 'ultimo_precio', 'agrupa_operacion']].to_excel(\n",
    "            ruta_df_operaciones, sheet_name='Operaciones', index=False\n",
    "        )\n",
    "\n",
    "        \n",
    "        print(\"Paso 08 OK\")\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------        \n",
    "        # Construye el nombre del archivo Excel basado en los parámetros\n",
    "        nombre_archivo_entrada = f'df_operaciones_{annus}_{num_dias_retroceder:03d}_{max_dias_ejecucion_venta:03d}.xlsx'\n",
    "        ruta_df_operaciones = os.path.join(carpeta_operaciones, nombre_archivo_entrada)\n",
    "\n",
    "        # Lee el archivo Excel en un DataFrame de pandas\n",
    "        df_operaciones = pd.read_excel(ruta_df_operaciones, sheet_name='Operaciones')\n",
    "\n",
    "        # Filtra el DataFrame para operaciones que comienzan con 'Operacion_C_'\n",
    "        df_rentabilidades = df_operaciones[df_operaciones['agrupa_operacion'].str.startswith('Operacion_C_')]\n",
    "        df_rentabilidades['fecha_formato'] = df_operaciones['fecha_formato']\n",
    "        df_rentabilidades['ultimo_precio_compra'] = df_operaciones['ultimo_precio']\n",
    "        df_rentabilidades['ultimo_precio_venta'] = df_operaciones['ultimo_precio'].shift(-1)\n",
    "        df_rentabilidades['dias_ejecuta_venta'] = df_rentabilidades['agrupa_operacion'].str[-3:]\n",
    "        df_rentabilidades['dias_ejecuta_venta'] = df_rentabilidades['dias_ejecuta_venta'].astype(int)\n",
    "        df_rentabilidades = df_rentabilidades[df_rentabilidades['agrupa_operacion'].str.startswith('Operacion_C_')]\n",
    "\n",
    "        # Agrega una nueva columna 'delta_operacion'\n",
    "        df_rentabilidades['delta_operacion'] = df_rentabilidades['ultimo_precio_venta'] - df_rentabilidades['ultimo_precio_compra']\n",
    "\n",
    "        df_rentabilidades['%_operacion'] = ((df_rentabilidades['delta_operacion'] / df_rentabilidades['ultimo_precio_compra']) * 100).round(2)\n",
    "\n",
    " \n",
    "        # Capital inicial\n",
    "        capital_inicial = 10000\n",
    "        df_rentabilidades['capital'] = 0.0  # Inicializa la columna 'capital'\n",
    "        \n",
    "        # Calcula la columna 'capital' usando la lógica descrita\n",
    "        df_rentabilidades.at[df_rentabilidades.index[0], 'capital'] = capital_inicial * (1 + df_rentabilidades.at[df_rentabilidades.index[0], '%_operacion'] / 100)*(1-(comision/100))\n",
    "        \n",
    "        for i in range(1, len(df_rentabilidades)):\n",
    "            df_rentabilidades.at[df_rentabilidades.index[i], 'capital'] = df_rentabilidades.at[df_rentabilidades.index[i - 1], 'capital'] * (1 + df_rentabilidades.at[df_rentabilidades.index[i], '%_operacion'] / 100)*(1-(comision/100))\n",
    "\n",
    "        # Calcula la rentabilidad anualizada para cada operación en df_rentabilidades\n",
    "        df_rentabilidades['rentabilidad_anualizada'] = (((df_rentabilidades['capital'] / capital_inicial) ** (1/annus) - 1) * 100).round(2)\n",
    "        \n",
    "        # Guarda los registros filtrados en un nuevo archivo Excel con la hoja llamada \"Rentabilidades\"\n",
    "        ruta_df_rentabilidades = os.path.join(carpeta_rentabilidades, f'df_rentabilidades_{annus}_{num_dias_retroceder:03d}_{max_dias_ejecucion_venta:03d}.xlsx')\n",
    "        df_rentabilidades.to_excel(ruta_df_rentabilidades, sheet_name='rentabilidades', index=False)\n",
    "\n",
    "        \n",
    "        print(\"Paso 09 OK\")\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#----------------------------------------------------------------------------------------------------------------------------- \n",
    "        # Lee el archivo Excel en un DataFrame de pandas\n",
    "        df_operaciones = pd.read_excel(ruta_df_operaciones, sheet_name='Operaciones')\n",
    "        \n",
    "        # Filtra el DataFrame para operaciones que comienzan con 'Operacion_C_'\n",
    "        df_rent_anio = df_operaciones[df_operaciones['agrupa_operacion'].str.startswith('Operacion_C_')]\n",
    "        \n",
    "        # Asigna los valores de las nuevas columnas\n",
    "        df_rent_anio['fecha_formato'] = df_operaciones['fecha_formato']\n",
    "        df_rent_anio['ultimo_precio_compra'] = df_operaciones['ultimo_precio']\n",
    "        df_rent_anio['ultimo_precio_venta'] = df_operaciones['ultimo_precio'].shift(-1)\n",
    "        df_rent_anio['dias_ejecuta_venta'] = df_rent_anio['agrupa_operacion'].str[-3:]\n",
    "        df_rent_anio['dias_ejecuta_venta'] = df_rent_anio['dias_ejecuta_venta'].astype(int)\n",
    "        df_rent_anio = df_rent_anio[df_rent_anio['agrupa_operacion'].str.startswith('Operacion_C_')]\n",
    "        \n",
    "        # Agrega una nueva columna 'delta_operacion'\n",
    "        df_rent_anio['delta_operacion'] = df_rent_anio['ultimo_precio_venta'] - df_rent_anio['ultimo_precio_compra']\n",
    "        \n",
    "        df_rent_anio['%_operacion'] = ((df_rent_anio['delta_operacion'] / df_rent_anio['ultimo_precio_compra']) * 100).round(2)\n",
    "        \n",
    "        # Capital inicial\n",
    "        capital_inicial = 10000\n",
    "        \n",
    "        # Calcula la columna 'capital' usando la lógica descrita, reiniciando en 10000 cada vez que cambia el año\n",
    "        for i in range(len(df_rent_anio)):\n",
    "            if i == 0 or df_rent_anio.at[df_rent_anio.index[i], 'fecha_formato'] != df_rent_anio.at[df_rent_anio.index[i - 1], 'fecha_formato']:\n",
    "                # Utiliza el porcentaje de operación para la primera operación de cada año\n",
    "                df_rent_anio.at[df_rent_anio.index[i], 'capital'] = capital_inicial * (1 + df_rent_anio.at[df_rent_anio.index[i], '%_operacion'] / 100)*(1-(comision/100))\n",
    "            else:\n",
    "                df_rent_anio.at[df_rent_anio.index[i], 'capital'] = df_rent_anio.at[df_rent_anio.index[i - 1], 'capital'] * (1 + df_rent_anio.at[df_rent_anio.index[i], '%_operacion'] / 100)*(1-(comision/100))\n",
    "        \n",
    "        # Calcula la rentabilidad anualizada para cada operación en df_rent_anio\n",
    "        df_rent_anio['rentabilidad_anualizada'] = (((df_rent_anio['capital'] / capital_inicial) ** (1/1) - 1) * 100).round(2)\n",
    "        \n",
    "        # Guarda los resultados en un nuevo archivo Excel con la hoja llamada \"Agrupado_Capital_10000\"\n",
    "        ruta_df_rent_anio = os.path.join(carpeta_rentabilidades, f'df_rent_anio_{annus}_{num_dias_retroceder:03d}_{max_dias_ejecucion_venta:03d}.xlsx')\n",
    "        df_rent_anio.to_excel(ruta_df_rent_anio, sheet_name='Agrupado', index=False)\n",
    "        \n",
    "        print(\"Paso 10 OK\")\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#----------------------------------------------------------------------------------------------------------------------------- \n",
    "\n",
    "        # Agrupa df_rentabilidades por año\n",
    "        df_rent_anio_grouped = df_rent_anio.groupby('fecha_formato')\n",
    "        \n",
    "        # Inicializa listas para cada columna del nuevo DataFrame\n",
    "        fecha_formato_anio_list = []\n",
    "        agrupa_operacion_anio_list = []\n",
    "        dias_ejecuta_venta_anio_list = []\n",
    "        porcentaje_operacion_anio_list = []\n",
    "        capital_inicial_anio_list = []\n",
    "        capital_final_anio_list = []\n",
    "        rent_anualizada_anio_list = []\n",
    "        \n",
    "        # Itera sobre cada grupo\n",
    "        for year, group in df_rent_anio_grouped:\n",
    "            # Añade información a las listas\n",
    "            fecha_formato_anio_list.append(year)\n",
    "            agrupa_operacion_anio_list.append(len(group['agrupa_operacion']))\n",
    "            dias_ejecuta_venta_anio_list.append(group['dias_ejecuta_venta'].mean())\n",
    "            porcentaje_operacion_anio_list.append(group['%_operacion'].mean())\n",
    "            capital_inicial_anio_list.append(capital_inicial)\n",
    "            capital_final_anio_list.append(group['capital'].iloc[-1])\n",
    "            rent_anualizada_anio_list.append(group['rentabilidad_anualizada'].iloc[-1])\n",
    "        \n",
    "        # Crea el nuevo DataFrame\n",
    "        df_rent_anio_unic = pd.DataFrame({\n",
    "            'fecha_formato_anio': fecha_formato_anio_list,\n",
    "            'agrupa_operacion_anio': agrupa_operacion_anio_list,\n",
    "            'dias_ejecuta_venta_anio': dias_ejecuta_venta_anio_list,\n",
    "            '%_operacion_anio': porcentaje_operacion_anio_list,\n",
    "            'capital_inicial_anio': capital_inicial_anio_list,\n",
    "            'capital_final_anio': capital_final_anio_list,\n",
    "            'rent_anualizada_anio': rent_anualizada_anio_list\n",
    "        })\n",
    "        print(\"Paso 11 OK\")  \n",
    "\n",
    "        # Especifica la ruta para guardar el nuevo archivo Excel\n",
    "        ruta_df_rent_anio_unic = os.path.join(carpeta_rentabilidades, f'df_rent_anio_unic_{annus}_{num_dias_retroceder:03d}_{max_dias_ejecucion_venta:03d}.xlsx')\n",
    "        \n",
    "        # Guarda el DataFrame en el nuevo archivo Excel\n",
    "        df_rent_anio_unic.to_excel(ruta_df_rent_anio_unic, sheet_name='Rent_Anio_Unic', index=False)\n",
    "\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "#-----------------------------------------------------------------------------------------------------------------------------\n",
    "\n",
    "        # Encuentra el último valor de la columna rentabilidad_anualizada\n",
    "        ultimo_valor_rentabilidad_anualizada = df_rentabilidades['rentabilidad_anualizada'].iloc[-1]\n",
    "\n",
    "        df_brief_data.append([\n",
    "            annus,\n",
    "            num_dias_retroceder,\n",
    "            max_dias_ejecucion_venta,\n",
    "            len(df_rentabilidades['agrupa_operacion'].unique()),\n",
    "            df_rentabilidades['dias_ejecuta_venta'].mean(),\n",
    "            df_rentabilidades['%_operacion'].mean(),\n",
    "            ultimo_valor_rentabilidad_anualizada\n",
    "        ])\n",
    "    \n",
    "        # Después de tus bucles, crea df_brief utilizando df_brief_data\n",
    "        df_brief = pd.DataFrame(df_brief_data, columns=df_brief_columns)\n",
    "\n",
    "        # Guarda df_brief en un archivo Excel\n",
    "        ruta_df_brief = os.path.join(carpeta_briefs, 'df_brief.xlsx')\n",
    "        df_brief.to_excel(ruta_df_brief, sheet_name='Brief', index=False)\n",
    "        \n",
    "        print(\"Paso 12 OK\") \n",
    "        \n",
    "        print(f\"\\nFINAL Iteración: {num_dias_retroceder} - {max_dias_ejecucion_venta}\")\n",
    "        # Guarda el tiempo de finalización\n",
    "        fin_tiempo = time.time()\n",
    "        \n",
    "# Calcula el tiempo transcurrido\n",
    "tiempo_transcurrido = round((fin_tiempo - inicio_tiempo)/60, 1)\n",
    "\n",
    "print(f\"El proceso tardó {tiempo_transcurrido} min en ejecutarse.\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "ebead2ba-8084-4b82-aa81-92f61f168f06",
   "metadata": {
    "tags": []
   },
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "Collecting yfinance\n",
      "  Obtaining dependency information for yfinance from https://files.pythonhosted.org/packages/09/82/5a5eee685095a6c1f8968db75bba8536baa8046c970be25e1ac91a843839/yfinance-0.2.33-py2.py3-none-any.whl.metadata\n",
      "  Using cached yfinance-0.2.33-py2.py3-none-any.whl.metadata (11 kB)\n",
      "Requirement already satisfied: pandas>=1.3.0 in c:\\users\\jlaho\\anaconda3\\lib\\site-packages (from yfinance) (2.0.3)\n",
      "Requirement already satisfied: numpy>=1.16.5 in c:\\users\\jlaho\\anaconda3\\lib\\site-packages (from yfinance) (1.24.3)\n",
      "Requirement already satisfied: requests>=2.31 in c:\\users\\jlaho\\anaconda3\\lib\\site-packages (from yfinance) (2.31.0)\n",
      "Collecting multitasking>=0.0.7 (from yfinance)\n",
      "  Using cached multitasking-0.0.11-py3-none-any.whl (8.5 kB)\n",
      "Requirement already satisfied: lxml>=4.9.1 in c:\\users\\jlaho\\anaconda3\\lib\\site-packages (from yfinance) (4.9.3)\n",
      "Requirement already satisfied: appdirs>=1.4.4 in c:\\users\\jlaho\\anaconda3\\lib\\site-packages (from yfinance) (1.4.4)\n",
      "Requirement already satisfied: pytz>=2022.5 in c:\\users\\jlaho\\anaconda3\\lib\\site-packages (from yfinance) (2023.3.post1)\n",
      "Collecting frozendict>=2.3.4 (from yfinance)\n",
      "  Obtaining dependency information for frozendict>=2.3.4 from https://files.pythonhosted.org/packages/b6/2c/e391d6d57bbd837d383a6b69b54ecb4768d75b31d8bc7a380b4b4afe4cb2/frozendict-2.3.10-py3-none-any.whl.metadata\n",
      "  Using cached frozendict-2.3.10-py3-none-any.whl.metadata (20 kB)\n",
      "Collecting peewee>=3.16.2 (from yfinance)\n",
      "  Using cached peewee-3.17.0-py3-none-any.whl\n",
      "Requirement already satisfied: beautifulsoup4>=4.11.1 in c:\\users\\jlaho\\anaconda3\\lib\\site-packages (from yfinance) (4.12.2)\n",
      "Collecting html5lib>=1.1 (from yfinance)\n",
      "  Using cached html5lib-1.1-py2.py3-none-any.whl (112 kB)\n",
      "Requirement already satisfied: soupsieve>1.2 in c:\\users\\jlaho\\anaconda3\\lib\\site-packages (from beautifulsoup4>=4.11.1->yfinance) (2.4)\n",
      "Requirement already satisfied: six>=1.9 in c:\\users\\jlaho\\anaconda3\\lib\\site-packages (from html5lib>=1.1->yfinance) (1.16.0)\n",
      "Requirement already satisfied: webencodings in c:\\users\\jlaho\\anaconda3\\lib\\site-packages (from html5lib>=1.1->yfinance) (0.5.1)\n",
      "Requirement already satisfied: python-dateutil>=2.8.2 in c:\\users\\jlaho\\anaconda3\\lib\\site-packages (from pandas>=1.3.0->yfinance) (2.8.2)\n",
      "Requirement already satisfied: tzdata>=2022.1 in c:\\users\\jlaho\\anaconda3\\lib\\site-packages (from pandas>=1.3.0->yfinance) (2023.3)\n",
      "Requirement already satisfied: charset-normalizer<4,>=2 in c:\\users\\jlaho\\anaconda3\\lib\\site-packages (from requests>=2.31->yfinance) (2.0.4)\n",
      "Requirement already satisfied: idna<4,>=2.5 in c:\\users\\jlaho\\anaconda3\\lib\\site-packages (from requests>=2.31->yfinance) (3.4)\n",
      "Requirement already satisfied: urllib3<3,>=1.21.1 in c:\\users\\jlaho\\anaconda3\\lib\\site-packages (from requests>=2.31->yfinance) (1.26.16)\n",
      "Requirement already satisfied: certifi>=2017.4.17 in c:\\users\\jlaho\\anaconda3\\lib\\site-packages (from requests>=2.31->yfinance) (2023.11.17)\n",
      "Using cached yfinance-0.2.33-py2.py3-none-any.whl (69 kB)\n",
      "Using cached frozendict-2.3.10-py3-none-any.whl (14 kB)\n",
      "Installing collected packages: peewee, multitasking, html5lib, frozendict, yfinance\n",
      "Successfully installed frozendict-2.3.10 html5lib-1.1 multitasking-0.0.11 peewee-3.17.0 yfinance-0.2.33\n"
     ]
    }
   ],
   "source": [
    "!pip install yfinance"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b1e8dd40-56ae-48a0-8bdb-de17d00b133f",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
